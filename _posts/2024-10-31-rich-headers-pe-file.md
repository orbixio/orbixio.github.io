---
title: Rich Header (PE File Format)
description: An introduction to undocumented structure called Rich Header found in PE (Portable Executable) files generated by Microsoft Build Tools.
author: orbixio
date: 2024-10-31 20:55:00 +0800
categories: [File Formats]
tags: [pe]
pin: true
media_subpath: '/posts/rich_header'
---

**Rich Header** is an undocumented structure found in PE (Portable Executable) files generated by Microsoft Build Tools. It is located immediately after the DOS Header and DOS Stub sections.

> The Rich Header is typically 128 bytes in size.

![](https://orbixio.netlify.app/assets/img/Pasted image 20241029075042.png)

![](https://orbixio.netlify.app/assets/img/Pasted image 20241029075052.png)

The easiest way to understand it is to start at the end, which is how it must be parsed.
The end of the rich header is demarked by the keyword “Rich”, or 0x68636952. It allows for easy identification of the Rich Header.

![Fig 1.1 - The RICH signature used to identify presence of data](https://orbixio.netlify.app/assets/img/Pasted image 20241029075238.png)

Immediately following the “Rich” keyword is a checksum that functions as an XOR key. It can be used to decrypt the rest of the header. 

![[Pasted image 20241029075356.png|*_Fig 1.2 - The highlighted part is checksum_*]]

If we use the key to XOR the data, working our way back we will find the DWORD “DanS” (0x536e6144) at the beginning of the header.

![[Pasted image 20241029075535.png|*_Fig 1.3 - XORed DWORD "DanS" (0x536e6144)_*]]

Decrypting the XORed DWORD "DanS" using checksum to get plain text data:

![[Pasted image 20241029080119.png]]

Following the DWORD “DanS” at beginning of the header are three null DWORDs used for padding.

![[Pasted image 20241029080315.png|*Fig 1.4 - Padding*]]

The rest of the rich header consists of data that fingerprints build information of the executable. Each entry is 8 bytes long and has the following structure:
```
struct RICH_ENTRY {
    ID         WORD
    Version    WORD
    Count      DWORD
}
```

![[Pasted image 20241029080443.png|*Fig 1.5 - Rich Data Enteries (Each lines represents one entry)*]]

![[Pasted image 20241029080508.png|*_Fig 1.6 - Copying these as a python array_*]]

Decrypting the XORed Rich Entries using the checksum in the header:
```python
# Function to (cipher_text ^ key) to get plain_text
def xor(data, key):
    return bytearray(a ^ b for a, b in zip(data, key * (len(data) // len(key)) + key[:len(data) % len(key)]))

# Source: Fig 1.2
key = bytearray.fromhex("F9ADAC05")

# Data copied using Copy as > Python Array
# Refer to Fig 1.6 
data = bytes([
    0xF0, 0xD5, 0x3F, 0x05, 0xF3, 0xAD, 0xAC, 0x05, 0xE9, 0x29, 0xAD, 0x04, 0xFA, 0xAD, 0xAC, 0x05, 
    0xE9, 0x29, 0xAF, 0x04, 0xFB, 0xAD, 0xAC, 0x05, 0xE9, 0x29, 0xA8, 0x04, 0xF0, 0xAD, 0xAC, 0x05, 
    0xE9, 0x29, 0xA9, 0x04, 0xEB, 0xAD, 0xAC, 0x05, 0xB2, 0xD5, 0xAD, 0x04, 0xFB, 0xAD, 0xAC, 0x05, 
    0xF9, 0xAD, 0xAD, 0x05, 0xCD, 0xAD, 0xAC, 0x05, 0xB2, 0x28, 0xA4, 0x04, 0xF8, 0xAD, 0xAC, 0x05, 
    0xB2, 0x28, 0x53, 0x05, 0xF8, 0xAD, 0xAC, 0x05, 0xB2, 0x28, 0xAE, 0x04, 0xF8, 0xAD, 0xAC, 0x05, 
])


# Decode the cipher data
xor(data, key)
```

![[Pasted image 20241029081148.png|*Fig 1.7 - Decrypting the XORed Rich Entries using the checksum in the header*]]

Splitting the decrypted Rich Entries into chunks of 8 bytes:
```python
# Function to (cipher_text ^ key) to get plain_text
def xor(data, key):
    return bytearray(a ^ b for a, b in zip(data, key * (len(data) // len(key)) + key[:len(data) % len(key)]))

# Source: Fig 1.2
key = bytearray.fromhex("F9ADAC05")

# Data copied using Copy as > Python Array
# Refer to Fig 1.6 
data = bytes([
    0xF0, 0xD5, 0x3F, 0x05, 0xF3, 0xAD, 0xAC, 0x05, 0xE9, 0x29, 0xAD, 0x04, 0xFA, 0xAD, 0xAC, 0x05, 
    0xE9, 0x29, 0xAF, 0x04, 0xFB, 0xAD, 0xAC, 0x05, 0xE9, 0x29, 0xA8, 0x04, 0xF0, 0xAD, 0xAC, 0x05, 
    0xE9, 0x29, 0xA9, 0x04, 0xEB, 0xAD, 0xAC, 0x05, 0xB2, 0xD5, 0xAD, 0x04, 0xFB, 0xAD, 0xAC, 0x05, 
    0xF9, 0xAD, 0xAD, 0x05, 0xCD, 0xAD, 0xAC, 0x05, 0xB2, 0x28, 0xA4, 0x04, 0xF8, 0xAD, 0xAC, 0x05, 
    0xB2, 0x28, 0x53, 0x05, 0xF8, 0xAD, 0xAC, 0x05, 0xB2, 0x28, 0xAE, 0x04, 0xF8, 0xAD, 0xAC, 0x05, 
])


# Decode the cipher data
rich_entries= xor(data, key)

# Refer to Fig 1.6
# Dividing the Rich Data Entries into 8 byte 
chunks = [''.join(f'{byte:02X}' for byte in rich_entries[i:i+8]) for i in range(0, len(rich_entries), 8)]

for i in chunks:
	print(i)
```

![[Pasted image 20241029081558.png|*Fig 1.8 - Splitting decrypted Rich Entries*]]


Each 8-byte chunk in `chunks` contains a decoded segment with the following structure:
![[Pasted image 20241029091626.png|*Fig 1.9 - Rich Entry Structure*]]

1. **ID**: A unique identifier for the entry, often used to specify the component or module type.
2. **Version**: Specifies the version of the associated component or module, useful for tracking software versions or build details.
3. **Count**: Indicates the number of times the component or module is referenced or utilized in the build process.

Using following code to extract the data in each Rich Entry:
```python
# Function to convert big-endian data to little-endian
def rev_endiannes(data):
	tmp = [data[i:i+8] for i in range(0, len(data), 8)]
	
	for i in range(len(tmp)):
		tmp[i] = "".join(reversed([tmp[i][x:x+2] for x in range(0, len(tmp[i]), 2)]))
	
	return "".join(tmp)

# Extracting id, version and count from rich entries
for i in chunks:
    print(f"{i}: {int(rev_endiannes(i[0:4]),16)}.{int(rev_endiannes(i[4:8]),16)}.{int(rev_endiannes(i[8:16]),16)}")

```

Here:

- `rev_endiannes()` is used to reverse the byte order of each part to match endianness requirements.
- `int(..., 16)` converts each reversed hex segment into an integer.

![[Pasted image 20241029092258.png|*Fig 1.9 - Extracted values from Rich Header*]]

Translating these values into the actual tools types and versions is a matter of collecting the values from actual Visual Studio installations.

##### Conclusion
We also looked at the Rich Header, a structure that’s not essentially a part of the PE file format but was worth checking.
